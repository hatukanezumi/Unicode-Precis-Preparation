/*
 * This file is automatically generated.  DON'T EDIT THIS FILE MANUALLY.
 */

#include "precis_preparation.h"

typedef enum {
    CCC_VIRAMA = 1,
    JT_D,
    JT_L,
    JT_R,
    JT_T,
    SC_Greek,
    SC_Han,
    SC_Hebrew,
    SC_Hiragana,
    SC_Katakana
} ctx_t;

typedef enum {
    ST_INIT = 0,
    ST_ZWNJ,
    ST_MIDDLEDOT,
    ST_KERAIA,
    ST_VIRAMA,
    ST_L_OR_D,
    ST_SMALLL,
    ST_HEBREW
} state_t;

static U16 precis_prop_index[] = {
    %s
};

static U8 precis_prop_array[] = {
    %s
};

U8 precis_prop_lookup(U32 cp)
{
    if ((cp & 0x00FFFE) == 0x00FFFE ||
	cp == 0x0E0001 || (0x0E0020 <= cp && cp <= 0x0E007F) ||
	(0x0E0100 <= cp && cp <= 0x0E01EF))
	return PRECIS_DISALLOWED;
    else if (0x040000 <= cp)
	return PRECIS_UNASSIGNED;

    return precis_prop_array[precis_prop_index[cp >> %d] +
			     (cp & ((1 << %d) - 1))
	];
}

static U16 precis_ctx_index[] = {
    %s
};

static U8 precis_ctx_array[] = {
    %s
};

U8 precis_ctx_lookup(U32 cp)
{
    if ((cp & 0x00FFFE) == 0x00FFFE || 0x040000 <= cp)
	return 0;

    return precis_ctx_array[precis_ctx_index[cp >> %d] +
			    (cp & ((1 << %d) - 1))
	];
}

static const U8 utf8_sequence_len[0x100] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x00-0x0F */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x10-0x1F */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x20-0x2F */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x30-0x3F */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x40-0x4F */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x50-0x5F */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x60-0x6F */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x70-0x7F */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x80-0x8F */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x90-0x9F */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xA0-0xAF */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xB0-0xBF */
    0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	/* 0xC0-0xCF */
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	/* 0xD0-0xDF */
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* 0xE0-0xEF */
    4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xF0-0xFF */
};

STRLEN precis_prepare(int stringclass, U8 * buf, const STRLEN buflen)
{
    U8 *p = buf;
    const U8 *end = buf + buflen;
    const U8 *end4 = end - 4;
    U32 vec, cp;
    STRLEN seqlen;
    state_t state = ST_INIT;
    U8 ctx, has_hankana, *kmdp, has_aid, has_eaid;

    has_hankana = 0;
    kmdp = NULL;
    has_aid = 0;
    has_eaid = 0;

    cp = 0;
    seqlen = 0;
    while (p < end4) {
      check:
	cp = 0;
	seqlen = utf8_sequence_len[*p];

	switch (seqlen) {
	case 0:
	    goto done;

	case 1:
	    /* 0xxxxxxx */
	    cp = (U32) p[0];
	    break;

	case 2:
	    /* 110xxxxx 10xxxxxx */
	    if ((p[1] & 0xC0) != 0x80)
		goto done;
	    cp = ((U32) (p[0] & 0x1F) << 6) | ((U32) (p[1] & 0x3F));
	    break;

	case 3:
	    vec = ((U32) p[0] << 16) | ((U32) p[1] << 8) | ((U32) p[2]);
	    /* 1110xxxx 10xxxxxx 10xxxxxx *//* Non-shortest form */
	    if ((vec & 0x00F0C0C0) != 0x00E08080 || vec < 0x00E0A080)
		goto done;
	    cp = ((U32) (p[0] & 0x0F) << 12)
		| ((U32) (p[1] & 0x3F) << 6) | ((U32) (p[2] & 0x3F));
	    /* Surrogates U+D800..U+DFFF */
	    if ((cp & 0x00D800) == 0x00D800)
		goto done;
	    /* Non-characters U+FDD0..U+FDEF, U+FFFE..U+FFFF */
	    if (0x00FDD0 <= cp && cp <= 0x00FDEF)
		goto done;
	    if ((cp & 0x00FFFE) == 0x00FFFE)
		goto done;
	    break;

	case 4:
	    vec = ((U32) p[0] << 24)
		| ((U32) p[1] << 16) | ((U32) p[2] << 8) | ((U32) p[3]);
	    /* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx *//* Non-shortest form */
	    if ((vec & 0xF8C0C0C0) != 0xF0808080 || vec < 0xF0908080)
		goto done;
	    cp = ((U32) (p[0] & 0x07) << 18)
		| ((U32) (p[1] & 0x3F) << 12)
		| ((U32) (p[2] & 0x3F) << 6) | ((U32) (p[3] & 0x3F));
	    /* Greater than U+10FFFF */
	    if (0x10FFFF < cp)
		goto done;
	    /* Non-characters U+nFFFE..U+nFFFF */
	    if ((cp & 0x00FFFE) == 0x00FFFE)
		goto done;
	    break;
	}

	if (stringclass != 0) {
	    switch (precis_prop_lookup(cp)) {
	    case PRECIS_PVALID:
	    case PRECIS_CONTEXTJ:
	    case PRECIS_CONTEXTO:
		break;

	    case PRECIS_ID_DIS:
		if (stringclass == PRECIS_IDENTIFIER_CLASS)
		    goto done;
		else
		    break;

	    default:
		goto done;
	    }

	    /* Apply contextual rules */
	    ctx = precis_ctx_lookup(cp);

	    /* Rule 1.2 bottom half */
	    if (state == ST_ZWNJ) {
		if (ctx == JT_T)
		    state = ST_ZWNJ;
		else if (ctx == JT_R || ctx == JT_D)
		    state = ST_INIT;
		else
		    goto done;
	    }
	    /* Rule 3 bottom half */
	    else if (state == ST_MIDDLEDOT) {
		if (cp == 0x00006C)	/* LATIN SMALL LETTER L */
		    state = ST_INIT;
		else
		    goto done;
	    }
	    /* Rule 4 bottom half */
	    else if (state == ST_KERAIA) {
		if (cp == 0x000375)	/* GREEK LOWER NUMERAL SIGN (keraia) */
		    state = ST_KERAIA;
		else if (ctx == SC_Greek && cp != 0x000375)	/* !keraia */
		    state = ST_INIT;
		else
		    goto done;
	    }
	    /* Rule 1.1: ZERO WIDTH NON-JOINER */
	    else if (ctx == CCC_VIRAMA)
		state = ST_VIRAMA;
	    else if (state == ST_VIRAMA && cp == 0x00200C)	/* ZWNJ */
		state = ST_INIT;
	    /* Rule 1.2: ZERO WIDTH NON-JOINER */
	    else if (ctx == JT_L || ctx == JT_D)
		state = ST_L_OR_D;
	    else if (state == ST_L_OR_D && ctx == JT_T)
		state = ST_L_OR_D;
	    else if (state == ST_L_OR_D && cp == 0x00200C)	/* ZWNJ */
		state = ST_ZWNJ;
	    else if (cp == 0x00200C)	/* ZWNJ */
		goto done;
	    /* Rule 2: ZERO WIDTH JOINER */
	    else if (ctx == CCC_VIRAMA)
		state = ST_VIRAMA;
	    else if (state == ST_VIRAMA && cp == 0x00200D)	/* ZWJ */
		state = ST_INIT;
	    else if (cp == 0x00200D)	/* ZWJ */
		goto done;
	    /* Rule 3: MIDDLE DOT */
	    else if (cp == 0x00006C)	/* LATIN SMALL LETTER L */
		state = ST_SMALLL;
	    else if (state == ST_SMALLL && cp == 0x0000B7)	/* MIDDLE DOT */
		state = ST_MIDDLEDOT;
	    /* Rule 4: GREEK LOWER NUMERAL SIGN */
	    else if (cp == 0x000375)	/* GREEK_LOWER_NUMERAL_SIGN */
		state = ST_KERAIA;
	    /* Rule 5: HEBREW PUNCTUATION GERESH */
	    else if (ctx == SC_Hebrew && cp != 0x0005F3 && cp != 0x0005F4)
		state = ST_HEBREW;
	    else if (state == ST_HEBREW && cp == 0x0005F3)	/* GERESH */
		state = ST_HEBREW;
	    else if (cp == 0x0005F3)	/* HEBREW PUNCTUATION GERESH */
		goto done;
	    /* Rule 6: HEBREW PUNCTUATION GERSHAYIM */
	    else if (ctx == SC_Hebrew && cp != 0x0005F3 && cp != 0x0005F4)
		state = ST_HEBREW;
	    else if (state == ST_HEBREW && cp == 0x0005F4)	/* GERSHAYIM */
		state = ST_HEBREW;
	    else if (cp == 0x0005F4)	/* HEBREW PUNCTUATION GERSHAYIM */
		goto done;
	    /* Clear state */
	    else if (state == ST_VIRAMA || state == ST_L_OR_D
		     || state == ST_SMALLL || state == ST_HEBREW)
		state = ST_INIT;

	    /* Rule 7: KATAKANA MIDDLE DOT */
	    if (ctx == SC_Han || ctx == SC_Hiragana || ctx == SC_Katakana)
		has_hankana = 1;
	    else if (cp == 0x0030FB	/* KATAKANA MIDDLE DOT */
		     && kmdp == NULL)
		kmdp = p;

	    /* Rule 8: ARABIC-INDIC DIGITS */
	    if (0x0660 <= cp && cp <= 0x0669) {	/* Arabic-Indic digits */
		if (has_eaid)
		    goto done;
		else
		    has_aid = 1;
	    }

	    /* Rule 9: EXTENDED ARABIC-INDIC DIGITS */
	    if (0x06F0 <= cp && cp <= 0x06F9) {	/* Ext. Arabic-Indic digits */
		if (has_aid)
		    goto done;
		else
		    has_eaid = 1;
	    }
	}

	p += seqlen;
    }
    if (p < end && p + utf8_sequence_len[*p] <= end)
	goto check;
    /* Clear state */
    if (state == ST_VIRAMA || state == ST_L_OR_D || state == ST_SMALLL
	|| state == ST_HEBREW)
	state = ST_INIT;

    if (kmdp != NULL && !has_hankana)
	p = kmdp;
    else if (state != ST_INIT)
	p -= seqlen;

  done:
    return (p == end) ? 1 : 0;
}
